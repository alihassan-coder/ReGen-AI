from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.orm import Session
from pydantic import BaseModel
from uuid import uuid4
import logging
from agent.tools import get_user_latest_form

from config.database_config import get_db
from routes.auth_routes import get_current_user
from models.tables_models import User
from agent.main_agent import get_agent

logger = logging.getLogger(__name__)


router = APIRouter(prefix="/agent", tags=["agent"])


class ChatRequest(BaseModel):
    message: str
    thread_id: str | None = None


class ChatResponse(BaseModel):
    reply: str
    thread_id: str
    search_results: dict = {}


@router.post("/chat", response_model=ChatResponse)
def chat(req: ChatRequest, db: Session = Depends(get_db), current_user: User = Depends(get_current_user)):
    thread_id = req.thread_id or str(uuid4())
    
    try:
        logger.info(f"Chat request from user {current_user.id}: {req.message[:50]}...")
        
        # Initialize agent
        agent = get_agent()
        
        # Fetch latest form now (avoid passing DB session into LangGraph state)
        form = get_user_latest_form(db, current_user.id)
        logger.info(f"User form data retrieved: {bool(form)}")
        
        # Get previous conversation history from checkpointer
        config = {"configurable": {"thread_id": thread_id}}
        try:
            previous_state = agent.get_state(config)
            previous_history = previous_state.values.get("conversation_history", []) if previous_state and previous_state.values else []
            logger.info(f"Loaded previous history: {len(previous_history)} messages")
        except Exception as e:
            logger.warning(f"Could not load previous state: {e}")
            previous_history = []
        
        state = {
            "user_id": current_user.id,
            "form": form,
            "message": req.message,
            "conversation_history": previous_history,  # Include previous history
        }
        
        # Invoke agent
        logger.info(f"Invoking agent with state keys: {list(state.keys())}, history size: {len(previous_history)}")
        
        # LangGraph with checkpointer returns the final state
        # Try different invocation methods
        try:
            result = agent.invoke(state, {"configurable": {"thread_id": thread_id}})
            logger.info(f"Agent invoke returned: type={type(result)}")
            
            # If result is None, try streaming and get last value
            if result is None:
                logger.warning("invoke returned None, trying stream method")
                final_state = None
                for chunk in agent.stream(state, {"configurable": {"thread_id": thread_id}}):
                    logger.info(f"Stream chunk: {chunk}")
                    final_state = chunk
                result = final_state
            
            if result is None:
                logger.error("Agent returned None even after streaming")
                raise RuntimeError("Agent returned None - check graph configuration")
            
            if not isinstance(result, dict):
                logger.error(f"Agent returned invalid response type: {type(result)}, value: {result}")
                raise RuntimeError(f"Agent returned invalid response type: {type(result)}")
            
            reply = result.get("reply")
            if not reply:
                logger.error(f"No reply in result. Result keys: {list(result.keys())}")
                raise RuntimeError("No reply generated by agent")
        except Exception as invoke_error:
            logger.error(f"Error during agent invocation: {invoke_error}", exc_info=True)
            raise
        
        # Get search results if available
        search_results = result.get("search_results", {})
        
        logger.info(f"Agent reply generated successfully: {len(reply)} chars, search performed: {bool(search_results.get('success'))}")
        return ChatResponse(reply=reply, thread_id=thread_id, search_results=search_results)
        
    except ValueError as e:
        # API key or configuration error
        logger.error(f"Configuration error: {e}")
        reply = f"Configuration error: {str(e)}"
        return ChatResponse(reply=reply, thread_id=thread_id)
        
    except Exception as e:
        # Log server-side and return a graceful message
        logger.error(f"Agent error: {type(e).__name__}: {str(e)}", exc_info=True)
        reply = (
            "I had an issue generating a reply just now. Please try again. "
            "If this keeps happening, check AI credentials and database connectivity. "
            f"Error: {str(e)[:100]}"
        )
        return ChatResponse(reply=reply, thread_id=thread_id)


